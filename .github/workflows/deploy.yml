name: Deploy Pipeline

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      backend_image:
        description: 'Backend Docker image'
        required: true
        default: 'ghcr.io/username/project-master/backend:latest'
      frontend_image:
        description: 'Frontend Docker image'
        required: true
        default: 'ghcr.io/username/project-master/frontend:latest'
      force_deploy:
        description: 'Force deployment (skip health checks)'
        required: false
        default: false
        type: boolean

env:
  DEPLOY_TIMEOUT: 300
  HEALTH_CHECK_RETRIES: 10

jobs:
  pre-deploy-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      can_deploy: ${{ steps.checks.outputs.can_deploy }}
      deployment_id: ${{ steps.deployment.outputs.deployment_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate inputs
        run: |
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Backend Image: ${{ github.event.inputs.backend_image }}"
          echo "Frontend Image: ${{ github.event.inputs.frontend_image }}"
          echo "Force Deploy: ${{ github.event.inputs.force_deploy }}"

      - name: Check Docker images exist
        run: |
          echo "Checking if Docker images exist..."
          docker manifest inspect ${{ github.event.inputs.backend_image }} > /dev/null
          docker manifest inspect ${{ github.event.inputs.frontend_image }} > /dev/null
          echo "✅ All images exist"

      - name: Create deployment
        id: deployment
        uses: actions/github-script@v6
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: '${{ github.event.inputs.environment }}',
              description: 'Deploying via GitHub Actions',
              auto_merge: false,
              required_contexts: []
            });
            
            core.setOutput('deployment_id', deployment.data.id);
            return deployment.data.id;

      - name: Set deployment status to in_progress
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ steps.deployment.outputs.deployment_id }}',
              state: 'in_progress',
              description: 'Deployment started'
            });

      - name: Pre-deployment checks
        id: checks
        run: |
          echo "can_deploy=true" >> $GITHUB_OUTPUT
          echo "✅ Pre-deployment checks passed"

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: pre-deploy-checks
    if: github.event.inputs.environment == 'staging' && needs.pre-deploy-checks.outputs.can_deploy == 'true'
    environment:
      name: staging
      url: https://staging.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to staging server
        run: |
          ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} << 'EOF'
            set -e
            
            # Create deployment directory
            mkdir -p /opt/project-manager
            cd /opt/project-manager
            
            # Download docker-compose file
            curl -o docker-compose.prod.yml https://raw.githubusercontent.com/${{ github.repository }}/main/docker-compose.prod.yml
            
            # Set environment variables
            export BACKEND_IMAGE="${{ github.event.inputs.backend_image }}"
            export FRONTEND_IMAGE="${{ github.event.inputs.frontend_image }}"
            export ENVIRONMENT="staging"
            
            # Pull latest images
            docker pull $BACKEND_IMAGE
            docker pull $FRONTEND_IMAGE
            
            # Stop existing containers
            docker-compose -f docker-compose.prod.yml down || true
            
            # Start new containers
            docker-compose -f docker-compose.prod.yml up -d
            
            # Wait for services to be ready
            sleep 30
            
            echo "✅ Deployment to staging completed"
          EOF

      - name: Health check
        run: |
          echo "Performing health check..."
          for i in {1..${{ env.HEALTH_CHECK_RETRIES }}}; do
            if curl -f -s https://staging.example.com/health > /dev/null; then
              echo "✅ Health check passed"
              exit 0
            fi
            echo "Health check attempt $i failed, retrying..."
            sleep 10
          done
          echo "❌ Health check failed after ${{ env.HEALTH_CHECK_RETRIES }} attempts"
          exit 1

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."
          # Add your smoke tests here
          curl -f -s https://staging.example.com/api/v1/projects > /dev/null
          echo "✅ Smoke tests passed"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-deploy-checks
    if: github.event.inputs.environment == 'production' && needs.pre-deploy-checks.outputs.can_deploy == 'true'
    environment:
      name: production
      url: https://example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Create backup
        run: |
          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
            # Create database backup
            docker exec postgres pg_dump -U project_user project_manager_db > /backup/db_$(date +%Y%m%d_%H%M%S).sql
            
            # Create application backup
            tar -czf /backup/app_$(date +%Y%m%d_%H%M%S).tar.gz /opt/project-manager
            
            echo "✅ Backup created"
          EOF

      - name: Deploy to production server
        run: |
          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << 'EOF'
            set -e
            
            # Navigate to deployment directory
            cd /opt/project-manager
            
            # Download latest docker-compose file
            curl -o docker-compose.prod.yml https://raw.githubusercontent.com/${{ github.repository }}/main/docker-compose.prod.yml
            
            # Set environment variables
            export BACKEND_IMAGE="${{ github.event.inputs.backend_image }}"
            export FRONTEND_IMAGE="${{ github.event.inputs.frontend_image }}"
            export ENVIRONMENT="production"
            
            # Pull latest images
            docker pull $BACKEND_IMAGE
            docker pull $FRONTEND_IMAGE
            
            # Rolling update strategy
            docker-compose -f docker-compose.prod.yml up -d --no-deps backend
            sleep 30
            docker-compose -f docker-compose.prod.yml up -d --no-deps frontend
            sleep 30
            
            # Clean up old images
            docker image prune -f
            
            echo "✅ Production deployment completed"
          EOF

      - name: Health check
        run: |
          echo "Performing production health check..."
          for i in {1..${{ env.HEALTH_CHECK_RETRIES }}}; do
            if curl -f -s https://example.com/health > /dev/null; then
              echo "✅ Production health check passed"
              exit 0
            fi
            echo "Health check attempt $i failed, retrying..."
            sleep 10
          done
          echo "❌ Production health check failed"
          exit 1

      - name: Run production smoke tests
        run: |
          echo "Running production smoke tests..."
          curl -f -s https://example.com/api/v1/projects > /dev/null
          curl -f -s https://example.com > /dev/null
          echo "✅ Production smoke tests passed"

  post-deploy:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks, deploy-staging, deploy-production]
    if: always() && needs.pre-deploy-checks.outputs.deployment_id
    steps:
      - name: Update deployment status
        uses: actions/github-script@v6
        with:
          script: |
            const deployJob = '${{ github.event.inputs.environment }}' === 'staging' 
              ? '${{ needs.deploy-staging.result }}'
              : '${{ needs.deploy-production.result }}';
            
            const state = deployJob === 'success' ? 'success' : 'failure';
            const description = deployJob === 'success' 
              ? 'Deployment completed successfully'
              : 'Deployment failed';
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ needs.pre-deploy-checks.outputs.deployment_id }}',
              state: state,
              description: description,
              environment_url: '${{ github.event.inputs.environment }}' === 'staging' 
                ? 'https://staging.example.com'
                : 'https://example.com'
            });

      - name: Send notification
        if: always()
        run: |
          STATUS="${{ job.status }}"
          ENV="${{ github.event.inputs.environment }}"
          
          if [ "$STATUS" = "success" ]; then
            MESSAGE="✅ Deployment to $ENV completed successfully!"
            curl -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
              -d "text=$MESSAGE" \
              -d "parse_mode=HTML"
          else
            MESSAGE="❌ Deployment to $ENV failed!"
            curl -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
              -d "text=$MESSAGE" \
              -d "parse_mode=HTML"
          fi

      - name: Deployment summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ github.event.inputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend Image | ${{ github.event.inputs.backend_image }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend Image | ${{ github.event.inputs.frontend_image }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ job.status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | https://${{ github.event.inputs.environment == 'production' && 'example.com' || 'staging.example.com' }} |" >> $GITHUB_STEP_SUMMARY 